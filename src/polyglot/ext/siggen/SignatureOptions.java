/******************************************************************** 
 * File          : SignatureOptions.java
 * Project       : siggen
 * Description   : Specialized options file containing signature-specific options
 * Author(s)     : dhking
 *  
 * Created       : Nov 30, 2007 4:33:35 PM
 *  Copyright (c) 2007 The Pennsylvania State University
 *  Systems and Internet Infrastructure Security Laboratory
 ********************************************************************
 */

package polyglot.ext.siggen;

import java.io.File;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import polyglot.frontend.ExtensionInfo;
import polyglot.main.Options;
import polyglot.main.UsageError;
import polyglot.main.Main.TerminationException;

public class SignatureOptions extends Options {

	/**
	 * The name of the ExtensionInfo object to load for parsing the file.
	 */
	public String sigExtensionInfo = "polyglot.frontend.JLExtensionInfo";
	
	/**
	 * The directory to output signatures to.
	 */
	public String signature_source_path = "sig-src/";
	
	/**
	 * The directory to output compiled signatures to. 
	 */
	public String signature_class_path = "sig-classes/";

	/**
	 * The directory to output inline signatures to.  (only created if
	 * -package has one or more entries)
	 */
	public String inline_signature_source_path =  "inline-sig-src/";

	
	/**
	 * Pointer to the jifc executable (defaults to the jifc in your $PATH)
	 */
	public String jifc = "jifc";

	
	/**
	 * The classpath for the Jif signatures of library objects.
	 */
	String sigcp = null;

	/**
	 * Additional classpath entries for Jif signatures.
	 */
	List<String> addSigcp = new ArrayList();

	/**
	 * Should we parameterize every signature? 
	 */
	public boolean should_parameterize = false;
	
	/**
	 * Packages to treat as special -- classes from source not in these packages
	 * will have signatures generated by them.  If no classes are specified, then
	 * all classes in the source are treated as special. 
	 */
	public Collection<String> packages = new HashSet<String>();
	
	/**
	 * Should we output inline classes?
	 */
	public boolean should_output_inline_classes = true;

	public SignatureOptions(ExtensionInfo extension) {
		super(extension);
	}

	@Override
	protected int parseCommand(String[] args, int index, Set source)
			throws UsageError, TerminationException {
		if (args[index].equals("-sigext")) {
			++index;
			sigExtensionInfo = args[index++];
		}
		else if (args[index].equals("-sigout")) {   // old option
			index++;
			this.signature_source_path = args[index++];
		}
		else if (args[index].equals("-sigsrc")) {
			index++;
			this.signature_source_path = args[index++];
		}
		else if (args[index].equals("-inlinesrc")) {
			++index;
			this.inline_signature_source_path = args[index++];
		}
		else if (args[index].equals("-sigclass")) {
			index++;
			this.signature_class_path = args[index++];
		}
		else if (args[index].equals("-sigcp")) {
			index++;
			this.sigcp = args[index++];
		}
		else if (args[index].equals("-addsigcp")) {
			index++;
			this.addSigcp.add(args[index++]);
		}
		else if (args[index].equals("-param")) {
			index++;
			this.should_parameterize = true;
		}
		else if (args[index].equals("-package")) {
			index++;
			this.packages.add(args[index]);
			++index;
		}

		return super.parseCommand(args, index, source);
	}
	
	@Override
	public void usage(PrintStream out) {
		super.usage(out);
		usageSubsection(out, "Signature Generation Options");
		usageForFlag(out, "-param", "parameterize output signature files with a label");
		usageForFlag(out, "-sigext <class>", "the polyglot extension for the files that you want to generate");
		usageForFlag(out, "-package <packageName>", "generate signatures for all classes except those in the specified package");
		usageForFlag(out, "-sigsrc <directory>", "the output directory for signature files (default: sig-src)");
		usageForFlag(out, "-inlinesrc <directory>", "the output directory for inline signature files (default: inline-sig-src)");
		usageForFlag(out, "-sigclass <directory>", "the output directory for compiled signature class (default: sig-class)");
		usageForFlag(out, "-jifc <executable>", "compile using a specific Jif compiler (default: 'jifc' in your path)");
		// DHK: usage for the Jif signature files
		usageForFlag(out, "-sigcp <path>", "path for Jif signatures (e.g. for java.lang.Object)");
		usageForFlag(out, "-addsigcp <path>", "additional path for Jif signatures; prepended to sigcp");
	}
	
	// DHK: cribbed from jif.JifOptions
	public String constructSignatureClasspath() {
		// use the signature classpath if it exists for compiling Jif classes
		String scp = "";
		for (Iterator iter = addSigcp.iterator(); iter.hasNext(); ) {
			scp += ((String)iter.next()) + File.pathSeparator;
		}
		if (sigcp != null) {
			scp += sigcp + File.pathSeparator;
		}
		return scp + constructFullClasspath();
	}
}
